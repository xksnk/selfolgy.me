"""
Onboarding DAO - Операции с ответами пользователей на вопросы

Работает ТОЛЬКО с:
- selfology.user_answers - ответы пользователей на вопросы из JSON
- Связывает users с question_id из intelligent_question_core
- Поддерживает версионирование ответов
"""

import logging
from datetime import datetime
from typing import Dict, Optional, Any, List
import asyncpg

from .service import DatabaseService

logger = logging.getLogger(__name__)

class OnboardingDAO:
    """Data Access Object для работы с ответами на вопросы онбординга"""
    
    def __init__(self, db_service: DatabaseService):
        self.db = db_service
    
    async def create_user_answers_table_if_needed(self):
        """Создать таблицу user_answers если не существует"""
        
        create_table_query = """
        CREATE TABLE IF NOT EXISTS user_answers (
            id SERIAL PRIMARY KEY,
            user_id VARCHAR(20) NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
            question_id VARCHAR(10) NOT NULL,
            answer_value INTEGER NOT NULL,
            answer_text TEXT,
            session_id VARCHAR(100),
            answered_at TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
            
            -- Метаданные из question core
            question_domain VARCHAR(50),
            question_depth_level VARCHAR(20),
            question_energy VARCHAR(20),
            
            -- Системная информация
            answer_version INTEGER DEFAULT 1,
            is_current BOOLEAN DEFAULT true,
            
            -- Уникальность: один текущий ответ на вопрос для пользователя
            UNIQUE(user_id, question_id, is_current) DEFERRABLE INITIALLY DEFERRED
        )
        """
        
        # Создаем индексы
        indexes = [
            "CREATE INDEX IF NOT EXISTS idx_user_answers_user_id ON user_answers(user_id)",
            "CREATE INDEX IF NOT EXISTS idx_user_answers_question ON user_answers(question_id)",
            "CREATE INDEX IF NOT EXISTS idx_user_answers_current ON user_answers(user_id, is_current) WHERE is_current = true",
            "CREATE INDEX IF NOT EXISTS idx_user_answers_domain ON user_answers(user_id, question_domain)",
            "CREATE INDEX IF NOT EXISTS idx_user_answers_session ON user_answers(session_id)",
        ]
        
        try:
            # Создаем таблицу
            await self.db.execute(create_table_query)
            
            # Создаем индексы
            for index_query in indexes:
                await self.db.execute(index_query)
            
            logger.info("✅ user_answers table and indexes created/verified")
            
        except Exception as e:
            logger.error(f"❌ Error creating user_answers table: {e}")
            raise
    
    async def save_answer(self, user_id: str, question_id: str, answer_value: int, 
                         answer_text: str = "", session_id: str = "", 
                         question_metadata: Optional[Dict] = None) -> bool:
        """Сохранить ответ пользователя на вопрос"""
        
        # Извлекаем метаданные вопроса
        domain = question_metadata.get('classification', {}).get('domain', '') if question_metadata else ''
        depth_level = question_metadata.get('classification', {}).get('depth_level', '') if question_metadata else ''
        energy = question_metadata.get('classification', {}).get('energy_dynamic', '') if question_metadata else ''
        
        query = """
        INSERT INTO user_answers (
            user_id, question_id, answer_value, answer_text, session_id,
            question_domain, question_depth_level, question_energy,
            answered_at
        ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9
        )
        ON CONFLICT (user_id, question_id, is_current)
        DO UPDATE SET
            answer_value = EXCLUDED.answer_value,
            answer_text = EXCLUDED.answer_text,
            answered_at = EXCLUDED.answered_at,
            answer_version = user_answers.answer_version + 1
        RETURNING id
        """
        
        try:
            result_id = await self.db.execute_query(
                query,
                user_id,
                question_id,
                answer_value,
                answer_text,
                session_id,
                domain,
                depth_level,
                energy,
                datetime.now()
            )
            
            logger.info(f"✅ Answer saved: user {user_id}, question {question_id}, value {answer_value}")
            return True
            
        except Exception as e:
            logger.error(f"❌ Error saving answer for user {user_id}, question {question_id}: {e}")
            return False
    
    async def get_user_answers(self, user_id: str, question_ids: Optional[List[str]] = None) -> List[Dict[str, Any]]:
        """Получить ответы пользователя"""
        
        if question_ids:
            query = """
            SELECT * FROM user_answers 
            WHERE user_id = $1 AND question_id = ANY($2) AND is_current = true
            ORDER BY answered_at DESC
            """
            args = (user_id, question_ids)
        else:
            query = """
            SELECT * FROM user_answers 
            WHERE user_id = $1 AND is_current = true
            ORDER BY answered_at DESC
            """
            args = (user_id,)
        
        try:
            rows = await self.db.fetch_all(query, *args)
            return [dict(row) for row in rows] if rows else []
            
        except Exception as e:
            logger.error(f"❌ Error getting answers for user {user_id}: {e}")
            return []
    
    async def get_user_progress(self, user_id: str) -> Dict[str, Any]:
        """Получить прогресс пользователя в онбординге"""
        
        query = """
        SELECT 
            COUNT(*) as total_answered,
            COUNT(DISTINCT question_domain) as domains_covered,
            MAX(answered_at) as last_answer_time,
            MIN(answered_at) as first_answer_time
        FROM user_answers 
        WHERE user_id = $1 AND is_current = true
        """
        
        try:
            row = await self.db.fetch_one(query, user_id)
            
            if row:
                progress_data = dict(row)
                progress_data['completion_percentage'] = round((progress_data['total_answered'] / 693) * 100, 1)
                return progress_data
            
            return {'total_answered': 0, 'completion_percentage': 0.0}
            
        except Exception as e:
            logger.error(f"❌ Error getting progress for user {user_id}: {e}")
            return {'total_answered': 0, 'completion_percentage': 0.0}
    
    async def get_answered_question_ids(self, user_id: str) -> List[str]:
        """Получить список ID вопросов на которые пользователь уже ответил"""
        
        query = "SELECT question_id FROM user_answers WHERE user_id = $1 AND is_current = true"
        
        try:
            rows = await self.db.fetch_all(query, user_id)
            return [row['question_id'] for row in rows] if rows else []
            
        except Exception as e:
            logger.error(f"❌ Error getting answered questions for user {user_id}: {e}")
            return []